# 流式传输需求分析文档

## 📋 背景

当前系统使用一次性生成报告的方式，生成时间较长（5分钟左右），用户体验不佳。需要改为流式传输，实现实时显示。

---

## ✅ 已确认需求

### 1. 预览版显示策略
- **未付费用户**：前端只显示预览版内容（约1800字符），但**后台继续接收完整内容**
- **到达预览边界后**：前端停止显示新内容，但后台继续接收并存储

### 2. 解锁时机处理
- **场景A**：用户在阅读完预览版后立即点击"解锁完整报告"
  - 即使此时流式传输未完成，后台仍**继续接收数据**
  - 解锁后，如果完整内容已接收完成，立即显示；如果还在传输，显示"正在加载完整内容..."

### 3. 前端显示优化
- **文字框自适应**：随着文字逐渐增加，显示容器逐渐变长（而不是固定高度+滚动）
- **滚动体验**：新增内容时自动滚动到底部（用户手动上滚时暂停自动滚动）

---

## ❓ 需要明确的问题

### 🔹 问题1：预览边界判定策略

**选项A：固定字符数**（当前方案）
- 优点：简单明确，易实现
- 缺点：可能在句子中间截断
- 实现：累计字符数达到1800后停止前端显示

**选项B：基于Markdown段落边界**
- 优点：预览版更完整，不会在句子中间断开
- 缺点：需要实时解析，可能稍有延迟
- 实现：检测段落结束标记（`\n\n`），在前一个完整段落后停止显示

**选项C：基于时间边界**
- 优点：动态调整预览长度
- 缺点：不确定性强，不同报告可能差异很大
- 实现：流式传输前30秒的内容作为预览

**推荐**：选项A（固定字符数）+ 选项B（优化截断点）
- 先统计字符数，到达1800字符附近时，寻找最近的段落边界（`\n\n`）作为截断点

---

### 🔹 问题2：数据库存储策略

**选项A：实时追加存储**
- 每收到一段数据（例如每500字符），立即更新数据库
- 优点：数据实时保存，即使中断也能保留大部分内容
- 缺点：数据库更新频繁，可能影响性能

**选项B：分批存储**
- 每收到N个字符（如5000字符）或每N秒（如30秒）更新一次数据库
- 优点：平衡了实时性和性能
- 缺点：中断时可能丢失最近一批数据

**选项C：流式传输完成后存储**
- 等所有内容接收完成后，一次性写入数据库
- 优点：最少数据库操作，性能最好
- 缺点：如果中断，可能丢失所有内容

**推荐**：选项B（分批存储，每3000字符或每30秒更新一次）

---

### 🔹 问题3：前端流式显示页面选择

**选项A：在 `/generate` 页面显示**
- 优点：用户可以看到实时的生成过程，体验更好
- 缺点：需要在生成完成后跳转到 `/report` 页面，需要处理状态传递

**选项B：在 `/report` 页面显示**
- 优点：符合当前流程（生成完成后跳转），页面结构更统一
- 缺点：需要先创建报告记录（可能只有部分内容），然后流式更新

**推荐**：选项B（在 `/report` 页面流式显示）
- 理由：符合当前流程，生成完成后创建报告记录并跳转，然后在该页面继续流式接收和显示

---

### 🔹 问题4：流式传输技术方案

**选项A：Server-Sent Events (SSE)**
- 优点：实现简单，Next.js原生支持，自动重连
- 缺点：只能服务器向客户端推送，不能双向通信

**选项B：WebSocket**
- 优点：双向通信，更灵活
- 缺点：实现复杂，需要额外的WebSocket服务器

**选项C：长轮询 (Long Polling)**
- 优点：兼容性好
- 缺点：实现复杂，效率低

**选项D：Next.js ReadableStream + fetch**
- 优点：使用原生fetch API，Next.js 13+ Route Handler支持流式响应
- 缺点：需要处理流解析

**推荐**：选项D（Next.js ReadableStream）
- 理由：Next.js 13+ 支持流式响应，使用简单，性能好

---

### 🔹 问题5：页面关闭/切换时的处理

**场景A：用户在流式传输过程中关闭页面**
- **处理策略**：
  - 后台API连接是否应该继续？
  - 如果继续，完整内容如何保存？
  - 用户重新打开报告页面时，如何判断流式传输是否完成？

**推荐方案**：
- 如果页面关闭，后台**继续接收**完整内容
- 使用 `beforeunload` 事件或 `visibilitychange` 检测页面关闭
- 后台API在客户端断开后继续接收，完成后更新数据库
- 用户重新打开报告页面时，检查 `full_report` 字段：
  - 如果有内容且完整，显示完整报告
  - 如果为空或不完整，说明流式传输中断或未完成，显示错误或提示重试

**场景B：从 `/generate` 跳转到 `/report` 页面**
- 流式传输连接如何保持？
- **推荐方案**：在 `/generate` 页面创建报告记录并获取reportId，跳转到 `/report?id=xxx`，`/report` 页面根据reportId继续流式接收

**场景C：用户在 `/report` 页面刷新**
- 如何处理正在进行的流式传输？
- **推荐方案**：检测到页面刷新时，保存当前已接收的内容到sessionStorage，刷新后检查数据库：
  - 如果完整内容已存储，直接显示
  - 如果未完成，从保存的进度继续（如果支持）或重新开始

---

### 🔹 问题6：解锁后的显示逻辑

**场景A：流式传输未完成时解锁**
- 显示策略：
  - **选项1**：显示"正在加载完整内容..."，等传输完成后自动显示
  - **选项2**：显示已接收的完整内容部分（即使未完成）

**推荐**：选项2（显示已接收的完整内容）
- 用户可以看到正在生成的完整内容，体验更好
- 在内容末尾显示"内容仍在生成中..."的提示

**场景B：流式传输完成后解锁**
- 直接显示完整内容（最简单的情况）

---

### 🔹 问题7：流式传输状态管理

**需要跟踪的状态**：
1. `streaming` - 正在流式传输
2. `preview_complete` - 预览版接收完成（但完整内容可能还在传输）
3. `full_complete` - 完整内容接收完成
4. `interrupted` - 传输中断
5. `failed` - 传输失败

**状态存储位置**：
- **前端状态**：React state（实时显示用）
- **后端状态**：数据库字段（持久化用）
  - 可选：在 `user_reports` 表添加 `streaming_status` 字段
  - 或者：通过 `full_report` 是否为空来判断

**推荐**：使用 `full_report` 字段判断
- 如果 `full_report` 为空或很短（< 5000字符），说明未完成
- 如果 `full_report` 有内容且长度合理（> 5000字符），说明已完成

---

### 🔹 问题8：错误处理和重试机制

**错误类型**：
1. **网络中断**：流式传输连接断开
2. **API超时**：ZhipuAI API超时
3. **API错误**：ZhipuAI返回错误
4. **存储错误**：数据库更新失败
5. **解析错误**：流式数据解析失败

**处理策略**：
- **网络中断**：前端自动重连（使用指数退避），后台继续接收
- **API超时/错误**：显示错误提示，提供"重新生成"按钮
- **存储错误**：重试3次，仍失败则记录错误日志，通知用户
- **解析错误**：跳过错误数据块，继续接收后续内容

---

### 🔹 问题9：前端显示容器样式

**需求**：随着文字越来越多，容器逐渐变长

**实现方案**：
- 使用CSS `min-height` 而不是固定 `height`
- 让容器随内容自动扩展
- 可能需要设置 `max-height: 80vh` 避免过长
- 超出最大高度时显示滚动条

**滚动行为**：
- 新增内容时自动滚动到底部
- 检测用户是否手动上滚，如果上滚了则暂停自动滚动
- 用户滚动到底部时恢复自动滚动

---

### 🔹 问题10：性能优化

**数据库更新优化**：
- 使用批量更新而不是每次单个字符更新
- 可以考虑使用 `JSONB` 增量更新（PostgreSQL特性）

**前端更新优化**：
- 使用 `requestAnimationFrame` 批处理DOM更新
- 考虑使用虚拟滚动（如果内容很长）
- 使用 `useMemo` 缓存解析后的HTML

**内存管理**：
- 如果内容很长（>10000字符），考虑分页显示
- 或者使用虚拟滚动只渲染可见部分

---

## 📊 总结表格

| 问题 | 推荐方案 | 备选方案 |
|------|----------|----------|
| 预览边界 | 固定字符数(1800) + 段落优化 | 纯时间边界 |
| 存储策略 | 分批存储(每3000字符/30秒) | 实时追加 / 完成后存储 |
| 显示页面 | `/report` 页面流式显示 | `/generate` 页面显示 |
| 技术方案 | Next.js ReadableStream | SSE / WebSocket |
| 页面关闭 | 后台继续接收 | 停止接收 |
| 解锁时机 | 显示已接收内容 | 等待传输完成 |
| 状态管理 | 用`full_report`字段判断 | 新增状态字段 |
| 容器样式 | `min-height` 自适应 | 固定高度 + 滚动 |

---

## 🎯 建议的实施步骤

1. **Phase 1: 后端流式API改造**
   - 修改 `zhipuService.ts` 支持流式传输
   - 创建流式API路由 `/api/reports/generate-stream`
   - 实现分批存储逻辑

2. **Phase 2: 前端流式显示**
   - 修改 `/generate` 页面：创建报告记录并跳转
   - 修改 `/report` 页面：支持流式接收和实时显示
   - 实现预览边界检测

3. **Phase 3: 状态管理和错误处理**
   - 实现传输状态跟踪
   - 实现错误处理和重试机制
   - 优化用户体验（加载状态、进度提示）

4. **Phase 4: 优化和测试**
   - 性能优化（数据库更新频率、前端渲染）
   - 各种场景测试（页面关闭、网络中断、快速解锁等）
   - 用户体验优化

---

## ❓ 需要您确认的问题

请确认以下选择：

1. **预览边界策略**：✅ 选项A+B（固定字符数 + 段落优化）
2. **存储策略**：✅ 选项B（分批存储，每3000字符/30秒）
3. **显示页面**：✅ 选项B（在 `/report` 页面流式显示）
4. **技术方案**：✅ 选项D（Next.js ReadableStream）
5. **页面关闭处理**：✅ 后台继续接收
6. **解锁时机**：✅ 显示已接收内容（即使未完成）
7. **容器样式**：✅ `min-height` 自适应增长

---

确认后即可开始实现！🚀
