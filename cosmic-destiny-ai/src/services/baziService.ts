import { BirthData, BaziData } from '@/types'
import { toDate } from 'date-fns-tz';

// Âº∫Âà∂ËÆæÁΩÆUTCÊó∂Âå∫ÔºåÁ°Æ‰øù‰∏éËÖæËÆØ‰∫ëÂºÄÂèëÁéØÂ¢É‰∏ÄËá¥
process.env.TZ = 'UTC';

export class BaziService {
  // ÁîüÊàêÊ®°ÊãüÁöÑÂÖ´Â≠óÊï∞ÊçÆÔºàÁî®‰∫éÊµãËØïÔºâ
  static generateMockBaziData(birthData: BirthData): BaziData {
    const mockStems = ['Áî≤', '‰πô', '‰∏ô', '‰∏Å', 'Êàä', 'Â∑±', 'Â∫ö', 'Ëæõ', 'Â£¨', 'Áô∏'];
    const mockBranches = ['Â≠ê', '‰∏ë', 'ÂØÖ', 'ÂçØ', 'Ëæ∞', 'Â∑≥', 'Âçà', 'Êú™', 'Áî≥', 'ÈÖâ', 'Êàå', '‰∫•'];
    
    // ÁîüÊàêÈöèÊú∫‰ΩÜÂõ∫ÂÆöÁöÑÂÖ´Â≠óÔºàÂü∫‰∫éÂá∫ÁîüÊó•ÊúüÁöÑÁÆÄÂçïÂìàÂ∏åÔºâ
    const dateHash = birthData.birthDate.split('-').reduce((acc, part) => acc + parseInt(part), 0);
    
    // Â§©Âπ≤ÂØπÂ∫îÁöÑ‰∫îË°å
    const stemElements: { [key: string]: 'WOOD' | 'FIRE' | 'EARTH' | 'METAL' | 'WATER' } = {
      'Áî≤': 'WOOD', '‰πô': 'WOOD',
      '‰∏ô': 'FIRE', '‰∏Å': 'FIRE',
      'Êàä': 'EARTH', 'Â∑±': 'EARTH',
      'Â∫ö': 'METAL', 'Ëæõ': 'METAL',
      'Â£¨': 'WATER', 'Áô∏': 'WATER'
    };
    
    // Â§©Âπ≤ÁöÑÈò¥Èò≥Â±ûÊÄß
    const stemNature: { [key: string]: 'Yang' | 'Yin' } = {
      'Áî≤': 'Yang', '‰πô': 'Yin',
      '‰∏ô': 'Yang', '‰∏Å': 'Yin',
      'Êàä': 'Yang', 'Â∑±': 'Yin',
      'Â∫ö': 'Yang', 'Ëæõ': 'Yin',
      'Â£¨': 'Yang', 'Áô∏': 'Yin'
    };
    
    const dayMasterStem = mockStems[(dateHash + 2) % 10];
    
    return {
      heavenlyStems: [
        mockStems[dateHash % 10],
        mockStems[(dateHash + 1) % 10],
        mockStems[(dateHash + 2) % 10],
        mockStems[(dateHash + 3) % 10]
      ],
      earthlyBranches: [
        mockBranches[dateHash % 12],
        mockBranches[(dateHash + 1) % 12],
        mockBranches[(dateHash + 2) % 12],
        mockBranches[(dateHash + 3) % 12]
      ],
      hiddenStems: [
        mockStems[(dateHash + 4) % 10],
        mockStems[(dateHash + 5) % 10],
        mockStems[(dateHash + 6) % 10]
      ],
      dayMaster: dayMasterStem,
      dayMasterNature: stemNature[dayMasterStem],
      dayMasterElement: stemElements[dayMasterStem],
      elements: {
        wood: Math.floor(Math.random() * 3) + 1,
        fire: Math.floor(Math.random() * 3) + 1,
        earth: Math.floor(Math.random() * 3) + 1,
        metal: Math.floor(Math.random() * 3) + 1,
        water: Math.floor(Math.random() * 3) + 1
      },
      yearPillar: mockStems[dateHash % 10] + mockBranches[dateHash % 12],
      monthPillar: mockStems[(dateHash + 1) % 10] + mockBranches[(dateHash + 1) % 12],
      dayPillar: mockStems[(dateHash + 2) % 10] + mockBranches[(dateHash + 2) % 12],
      hourPillar: mockStems[(dateHash + 3) % 10] + mockBranches[(dateHash + 3) % 12]
    };
  }

  static async calculateBazi(birthData: BirthData): Promise<BaziData> {
    try {
      // Import the bazi calculator dynamically to avoid SSR issues
      const baziModule = await import('@aharris02/bazi-calculator-by-alvamind')

      const BaziCalculator = baziModule.BaziCalculator;

      let birthDateTimeString;
      if(birthData.isTimeKnownInput){
        // ÂΩìÁî®Êà∑Êèê‰æõ‰∫ÜÂÖ∑‰ΩìÊó∂Èó¥Êó∂Ôºå‰ΩøÁî®Áî®Êà∑ËæìÂÖ•ÁöÑÊó∂Èó¥
        birthDateTimeString = `${birthData.birthDate}T${birthData.birthTime}:00`
      }else{
        // ÂΩìÁî®Êà∑Ê≤°ÊúâÊèê‰æõÊó∂Èó¥Êó∂Ôºå‰ΩøÁî®ÈªòËÆ§Êó∂Èó¥ 12:00:00
        birthDateTimeString = `${birthData.birthDate}T12:00:00`
      }

      console.log('üîÆ [BaziService] Âá∫ÁîüÊó•ÊúüÊó∂Èó¥Â≠óÁ¨¶‰∏≤:', birthDateTimeString)
      console.log('üîÆ [BaziService] ÊòØÂê¶Â∑≤Áü•Âá∫ÁîüÊó∂Èó¥:', birthData.isTimeKnownInput)
      console.log('üîÆ [BaziService] Áî®Êà∑ËæìÂÖ•ÁöÑÂá∫ÁîüÊó∂Èó¥:', birthData.birthTime)
      console.log('üîÆ [BaziService] Êó∂Âå∫:', birthData.timeZone)
      console.log('üîÆ [BaziService] ÊÄßÂà´:', birthData.gender)
      
      // Âº∫Âà∂ËÆæÁΩÆUTCÊó∂Âå∫ÁéØÂ¢É
      process.env.TZ = 'UTC'
      
      // Ê£ÄÊü•ÂΩìÂâçÁéØÂ¢ÉÁöÑÊó∂Âå∫ËÆæÁΩÆ
      console.log('üîÆ [BaziService] Âº∫Âà∂ËÆæÁΩÆÊó∂Âå∫‰∏∫UTC')
      console.log('üîÆ [BaziService] ÂΩìÂâçÁéØÂ¢ÉÊó∂Âå∫ TZ:', process.env.TZ)
      console.log('üîÆ [BaziService] ÂΩìÂâçÁ≥ªÁªüÊó∂Âå∫ÂÅèÁßª:', new Date().getTimezoneOffset())
      console.log('üîÆ [BaziService] ÂΩìÂâçÊó∂Èó¥UTC:', new Date().toISOString())
      console.log('üîÆ [BaziService] ÂΩìÂâçÊó∂Èó¥Êú¨Âú∞:', new Date().toString())
      
      // Ê£ÄÊü•Êó∂Âå∫Ê†ºÂºèÂíåÊúâÊïàÊÄß
      try {
        const testDate = new Date()
        const timeZoneTest = Intl.DateTimeFormat(undefined, { timeZone: birthData.timeZone }).resolvedOptions().timeZone
        console.log('üîÆ [BaziService] Êó∂Âå∫È™åËØÅ - ËæìÂÖ•:', birthData.timeZone, 'Ëß£ÊûêÁªìÊûú:', timeZoneTest)
      } catch (error) {
        console.error('üîÆ [BaziService] Êó∂Âå∫È™åËØÅÂ§±Ë¥•:', error)
      }

      const birthDate = toDate(birthDateTimeString, { timeZone: birthData.timeZone })
      console.log('üîÆ [BaziService] Âá∫ÁîüÊó•Êúü:', birthDate)
      console.log('üîÆ [BaziService] Âá∫ÁîüÊó•ÊúüUTC:', birthDate.toISOString())
      console.log('üîÆ [BaziService] Âá∫ÁîüÊó•ÊúüÊú¨Âú∞Êó∂Èó¥:', birthDate.toString())
      
      // È™åËØÅÊó∂Âå∫ËΩ¨Êç¢ÂêéÁöÑÁªìÊûú
      console.log('üîÆ [BaziService] È™åËØÅÊó∂Âå∫ËΩ¨Êç¢:')
      console.log('- ÂéüÂßãËæìÂÖ•Êó∂Èó¥Â≠óÁ¨¶‰∏≤:', birthDateTimeString)
      console.log('- ÊåáÂÆöÊó∂Âå∫:', birthData.timeZone)
      console.log('- ËΩ¨Êç¢ÂêéÁöÑDateÂØπË±°:', birthDate)
      console.log('- ËΩ¨Êç¢ÂêéÁöÑUTCÊó∂Èó¥:', birthDate.toISOString())
      console.log('- ËΩ¨Êç¢ÂêéÁöÑÊú¨Âú∞ÊòæÁ§∫:', birthDate.toString())
      console.log('- ËΩ¨Êç¢ÂêéÁöÑUTCÂ≠óÁ¨¶‰∏≤:', birthDate.toUTCString())

      // Create bazi calculator instance
      console.log('üîÆ [BaziService] ÂàõÂª∫BaziCalculatorÂèÇÊï∞:')
      console.log('- birthDate:', birthDate)
      console.log('- gender:', birthData.gender)
      console.log('- timeZone:', birthData.timeZone)
      console.log('- isTimeKnownInput:', birthData.isTimeKnownInput)
      
      // Á°Æ‰øùÂú®UTCÁéØÂ¢É‰∏ãÂàõÂª∫BaziCalculator
      // ËøôÊ†∑ÂèØ‰ª•Á°Æ‰øù‰∏éËÖæËÆØ‰∫ëÂºÄÂèëÁéØÂ¢ÉÁöÑËÆ°ÁÆóÁªìÊûú‰∏ÄËá¥
      const calculator = new BaziCalculator(birthDate, birthData.gender, 'UTC', birthData.isTimeKnownInput)

      console.log("üîÆ [BaziService] calculator.toString():",calculator.toString())
      
      // È™åËØÅËÆ°ÁÆóÂô®ÂàõÂª∫ÂêéÁöÑÁéØÂ¢ÉÁä∂ÊÄÅ
      console.log('üîÆ [BaziService] ËÆ°ÁÆóÂô®ÂàõÂª∫ÂêéÈ™åËØÅ:')
      console.log('- ÂΩìÂâçËøõÁ®ãÊó∂Âå∫:', process.env.TZ)
      console.log('- Êñ∞Date()ÊòæÁ§∫:', new Date().toString())
      console.log('- ‰º†ÂÖ•ÁöÑbirthDate:', birthDate.toString())
      console.log('- birthDate UTC:', birthDate.toISOString())
      
      // Calculate comprehensive bazi analysis
      const analysis = calculator.getCompleteAnalysis();
      
      // ÊâìÂç∞Â§©Âπ≤Âú∞ÊîØ8‰∏™Â≠ó
      if (analysis?.mainPillars) {
        const yearPillar = analysis.mainPillars.year;
        const monthPillar = analysis.mainPillars.month;
        const dayPillar = analysis.mainPillars.day;
        const hourPillar = analysis.mainPillars.time;
        
        console.log("üîÆ [BaziService] Â§©Âπ≤Âú∞ÊîØ8‰∏™Â≠ó:");
        console.log(`Âπ¥Êü±: ${yearPillar?.chinese || 'N/A'}`);
        console.log(`ÊúàÊü±: ${monthPillar?.chinese || 'N/A'}`);
        console.log(`Êó•Êü±: ${dayPillar?.chinese || 'N/A'}`);
        console.log(`Êó∂Êü±: ${hourPillar?.chinese || 'N/A'}`);
        
        // ‰ªéchineseÂ≠óÊÆµÊèêÂèñ8‰∏™Â≠óÁ¨¶ÔºàÊØè‰∏™Êü±ÂåÖÂê´Â§©Âπ≤Âú∞ÊîØ2‰∏™Â≠óÁ¨¶Ôºâ
        const eightCharacters = [
          yearPillar?.chinese,
          monthPillar?.chinese,
          dayPillar?.chinese,
          hourPillar?.chinese
        ].filter(Boolean).join('');
        
        console.log(`üîÆ [BaziService] ÂÖ´Â≠ó8‰∏™Â≠ó: ${eightCharacters}`);
        
        // Â¶ÇÊûúÈúÄË¶ÅÂçïÁã¨ÁöÑÂ§©Âπ≤Âú∞ÊîØÂ≠óÁ¨¶ÔºåÂèØ‰ª•‰ªédetailedPillarsËé∑Âèñ
        if (analysis.detailedPillars) {
          console.log("üîÆ [BaziService] ËØ¶ÁªÜÂ§©Âπ≤Âú∞ÊîØ‰ø°ÊÅØ:");
          console.log(`Âπ¥Âπ≤: ${analysis.detailedPillars.year?.heavenlyStem?.character || ''}`);
          console.log(`Âπ¥ÊîØ: ${analysis.detailedPillars.year?.earthlyBranch?.character || ''}`);
          console.log(`ÊúàÂπ≤: ${analysis.detailedPillars.month?.heavenlyStem?.character || ''}`);
          console.log(`ÊúàÊîØ: ${analysis.detailedPillars.month?.earthlyBranch?.character || ''}`);
          console.log(`Êó•Âπ≤: ${analysis.detailedPillars.day?.heavenlyStem?.character || ''}`);
          console.log(`Êó•ÊîØ: ${analysis.detailedPillars.day?.earthlyBranch?.character || ''}`);
          console.log(`Êó∂Âπ≤: ${analysis.detailedPillars.hour?.heavenlyStem?.character || ''}`);
          console.log(`Êó∂ÊîØ: ${analysis.detailedPillars.hour?.earthlyBranch?.character || ''}`);
        }
      }
      const luckPillars = calculator.calculateLuckPillars();
      const interactions = calculator.calculateInteractions();
      
      if (!analysis) {
        throw new Error('Failed to calculate Bazi analysis')
      }

      // Map the analysis to our enhanced BaziData interface
      const pillars = [
        analysis.mainPillars.year,
        analysis.mainPillars.month,
        analysis.mainPillars.day,
        analysis.mainPillars.time
      ].filter(Boolean) // Remove null values
      
      const baziData: BaziData = {
        // Âü∫Á°ÄÂõõÊü±‰ø°ÊÅØ
        heavenlyStems: pillars.map((p: any) => p.heavenlyStem?.character || ''),
        earthlyBranches: pillars.map((p: any) => p.earthlyBranch?.character || ''),
        hiddenStems: pillars.map((p: any) => p.hiddenStems?.map((hs: any) => hs.character) || []).flat(),
        yearPillar: analysis.mainPillars.year?.chinese || '',
        monthPillar: analysis.mainPillars.month?.chinese || '',
        dayPillar: analysis.mainPillars.day?.chinese || '',
        hourPillar: analysis.mainPillars.time?.chinese || '',
        
        // Êó•‰∏ª‰ø°ÊÅØ
        dayMaster: analysis.basicAnalysis?.dayMaster?.stem || '',
        dayMasterNature: analysis.basicAnalysis?.dayMaster?.nature || 'Yang',
        dayMasterElement: analysis.basicAnalysis?.dayMaster?.element || 'WOOD',
        
        // ‰∫îË°åÂàÜÊûê
        elements: {
          wood: analysis.basicAnalysis?.fiveFactors?.WOOD || 0,
          fire: analysis.basicAnalysis?.fiveFactors?.FIRE || 0,
          earth: analysis.basicAnalysis?.fiveFactors?.EARTH || 0,
          metal: analysis.basicAnalysis?.fiveFactors?.METAL || 0,
          water: analysis.basicAnalysis?.fiveFactors?.WATER || 0
        },
        
        // Êó•‰∏ªÂº∫Âº±ÂàÜÊûê
        dayMasterStrength: analysis.basicAnalysis?.dayMasterStrength ? {
          strength: analysis.basicAnalysis.dayMasterStrength.strength,
          score: analysis.basicAnalysis.dayMasterStrength.score,
          notes: analysis.basicAnalysis.dayMasterStrength.notes
        } : undefined,
        
        // ÊúâÂà©ÂÖÉÁ¥†ÂàÜÊûê
        favorableElements: analysis.basicAnalysis?.favorableElements ? {
          primary: analysis.basicAnalysis.favorableElements.primary,
          secondary: analysis.basicAnalysis.favorableElements.secondary,
          unfavorable: analysis.basicAnalysis.favorableElements.unfavorable,
          notes: analysis.basicAnalysis.favorableElements.notes
        } : undefined,
        
        // ÂÖ´ÂÆÖÂàÜÊûê
        eightMansions: analysis.basicAnalysis?.eightMansions ? {
          group: analysis.basicAnalysis.eightMansions.group,
          lucky: {
            wealth: analysis.basicAnalysis.eightMansions.lucky.wealth,
            health: analysis.basicAnalysis.eightMansions.lucky.health,
            romance: analysis.basicAnalysis.eightMansions.lucky.romance,
            career: analysis.basicAnalysis.eightMansions.lucky.career
          },
          unlucky: {
            obstacles: analysis.basicAnalysis.eightMansions.unlucky.obstacles,
            quarrels: analysis.basicAnalysis.eightMansions.unlucky.quarrels,
            setbacks: analysis.basicAnalysis.eightMansions.unlucky.setbacks,
            totalLoss: analysis.basicAnalysis.eightMansions.unlucky.totalLoss
          }
        } : undefined,
        
        // Âü∫Êú¨ÂàÜÊûê
        lifeGua: analysis.basicAnalysis?.lifeGua,
        nobleman: analysis.basicAnalysis?.nobleman,
        intelligence: analysis.basicAnalysis?.intelligence,
        skyHorse: analysis.basicAnalysis?.skyHorse,
        peachBlossom: analysis.basicAnalysis?.peachBlossom,
        
        // Â§ßËøê‰ø°ÊÅØ
        luckPillars: luckPillars ? {
          pillars: luckPillars.pillars.map(p => ({
            number: p.number,
            heavenlyStem: p.heavenlyStem.character,
            earthlyBranch: p.earthlyBranch.character,
            yearStart: p.yearStart,
            yearEnd: p.yearEnd,
            ageStart: p.ageStart
          })),
          incrementRule: luckPillars.incrementRule,
          isTimingKnown: luckPillars.isTimingKnown
        } : undefined,
        
        // Áõ∏‰∫í‰ΩúÁî®ÂàÜÊûê
        interactions: interactions?.map(i => ({
          type: i.type,
          participants: i.participants.map(p => ({
            pillar: p.pillar,
            source: p.source,
            elementChar: p.elementChar,
            elementType: p.elementType
          })),
          description: i.description,
          involvesFavorableElement: i.involvesFavorableElement,
          involvesUnfavorableElement: i.involvesUnfavorableElement
        }))
      }

      return baziData
    } catch (error) {
      console.error('Error calculating Bazi:', error)
      console.warn('‚ö†Ô∏è [BaziService] ‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆËøõË°åÊµãËØï')
      
      // Â¶ÇÊûúËÆ°ÁÆóÂ§±Ë¥•ÔºàÊØîÂ¶ÇÁº∫Â∞ë‰æùËµñÂåÖÔºâÔºåËøîÂõûÊ®°ÊãüÊï∞ÊçÆ
      return this.generateMockBaziData(birthData)
    }
  }

  static getElementAnalysis(elements: BaziData['elements']): string {
    const total = Object.values(elements).reduce((sum, val) => sum + val, 0)
    if (total === 0) return 'Balanced elements'

    const percentages = {
      wood: Math.round((elements.wood / total) * 100),
      fire: Math.round((elements.fire / total) * 100),
      earth: Math.round((elements.earth / total) * 100),
      metal: Math.round((elements.metal / total) * 100),
      water: Math.round((elements.water / total) * 100)
    }

    // Find dominant element
    const dominant = Object.entries(percentages).reduce((a, b) =>
      percentages[a[0] as keyof typeof percentages] > percentages[b[0] as keyof typeof percentages] ? a : b
    )[0]

    const elementNames = {
      wood: 'Wood (Êú®)',
      fire: 'Fire (ÁÅ´)',
      earth: 'Earth (Âúü)',
      metal: 'Metal (Èáë)',
      water: 'Water (Ê∞¥)'
    }

    return `Dominant Element: ${elementNames[dominant as keyof typeof elementNames]} (${percentages[dominant as keyof typeof percentages]}%)`
  }

  static getDayMasterCharacteristics(dayMaster: string): string {
    const characteristics: { [key: string]: string } = {
      'Áî≤': 'Natural leader, ambitious, and straightforward. You have strong wood element energy.',
      '‰πô': 'Gentle, adaptable, and cooperative. You possess flexible wood energy.',
      '‰∏ô': 'Energetic, enthusiastic, and outgoing. You radiate fire energy.',
      '‰∏Å': 'Warm, thoughtful, and detail-oriented. You have gentle fire energy.',
      'Êàä': 'Reliable, stable, and practical. You embody earth element energy.',
      'Â∑±': 'Nurturing, supportive, and humble. You have receptive earth energy.',
      'Â∫ö': 'Determined, disciplined, and righteous. You possess strong metal energy.',
      'Ëæõ': 'Elegant, precise, and detail-oriented. You have refined metal energy.',
      'Â£¨': 'Resourceful, adaptable, and intelligent. You flow with water energy.',
      'Áô∏': 'Intuitive, gentle, and compassionate. You have deep water energy.'
    }

    return characteristics[dayMaster] || 'Unique individual with special cosmic energy.'
  }
}